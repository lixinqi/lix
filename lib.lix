#!/usr/local/bin/node ./lix.js
join := (arr)->{
	ret := ""
	arr foreach (i)->{
		ret = ret + i
	}
	ret
}

map := (arr cb)->{
	ret := []
	arr foreach (i index)->{
		ret .push (i cb index)
	}
	ret
}

counterGenerator := ()->{
	counter := 0
	()->{
		ret := counter
		counter = counter + 1
		ret
	}
}

getCount := counterGenerator call

getUniqVarName := ()->{ '_uniq_val_' + (getCount call) }

generateFuncArgs := (args env ctx)->{
	args map (i)->{
		varname := i.0
		env.[varname] = true
		varname
	} | .join ', '
}

ctx0 := (x)->{x}

generateSeq := (expr env ctx)->{
	last := expr.[0].length - 1
	seqCtx := (index)->{
		if (index < last) {
			ctx0
		} else {
			ctx
		}
	}
	expr.0 map (item index)->{
		item generate env (index seqCtx)
	} | .join ";\n" | + ";\n"
}

generateOr := (expr env ctx)->{
	['(' (expr.0 generate env ctx0) " || " (expr.2 generate env ctx0) ')'] join
}

generateAnd := (expr env ctx)->{
	['(' (expr.0 generate env ctx0) " && " (expr.2 generate env ctx0) ')'] join
}

generateIf := (expr env ctx)->{
	expr.0 map (i)->{
		if (i.1 == 'else') {
			['{\n' (i.0 generate env ctx) '\n}'] join
		} (i.1 == 'if') {
			(i generateIf env ctx)
		} else {
			[ 'if (' (i.0 generate env ctx0) ') {\n'
					(i.1 generate env ctx)
				'\n}'
			] join
		}
	} | .join ' else '
}

operateFuncName := {
	.["+"] '__add__'
	.["-"] '__sub__'
	.["*"] '__mul__'
	.["/"] '__div__'
	.["%"] '__mod__'
	.[">="] '__ge__'
	.[">"] '__gt__'
	.["=="] '__eq__'
	.["<"] '__lt__'
	.["<="] '__le__'
}

generateAtomic := (expr env ctx)->{
	ret := expr.0
	if (expr.2 == '{var}') {
		if (operateFuncName.[expr.0]) {
			ret = operateFuncName.[expr.0]
		} else {
			ret = expr.0 transformVarName
		}
	}
	ret ctx
}

generatePropertyName := (expr env ctx)->{
	if (expr.1 == '{atomic}') {
		expr generateAtomic env ctx0 | ctx
	} (expr.1 == '{index}') {
		expr.0 generateAtomic env ctx0 | ctx
	}
}

generateProperty := (expr env ctx)->{
	propertyName := expr.0 generatePropertyName env ctx0
	propertyValue := expr.2 generate env ctx0
	propertyName | + ": " | + propertyValue
}

generateObjectLiteral := (expr env ctx)->{
	objectBody := expr.0 map (i)->{
		(i generateProperty env ctx0)
	} | .join ",\n"
	["{\n" objectBody "\n}"] | join | ctx
}

transformVarName := (name)->{ name }

getVarName := (expr)->{
	if (expr.1 == '{atomic}') {
		expr generateAtomic {} ctx0
	} (expr.1 == '{.}') {
		expr.0 getVarName
	}
}

generateField := (expr env ctx)->{
	if (expr.1 == '{atomic}') {
		'.' + (expr generateAtomic env ctx0)
	} (expr.1 == '{index}') {
		['[' (expr.0 generate env ctx0) ']'] join
	}
}


generateFieldAccess := (expr env ctx)->{
	if (expr.1 == '{atomic}') {
		expr generateAtomic env ctx0 | ctx
	} (expr.1 == '{.}') {
		obj := (expr.0 generateFieldAccess env ctx0)
		field := (expr.2 generateField env ctx0)
		obj + field | ctx
	}
}

generateArray := (expr env ctx)->{
	arrayBody := expr.0 map (i)->{
		(i generate env ctx0)
	} | .join ', '
	['[' arrayBody ']'] | join | ctx
}

generateMethod := (expr env ctx)->{
	localVarName := getUniqVarName call
	localValueName := getUniqVarName call
	method := localVarName + (expr.0 generateField env ctx0)
	['(function (' localVarName ", " localValueName ") {\n"
			"if (typeof " method " === 'function') {\n"
				"arguments = Array.prototype.slice.call(arguments, 1, arguments.length);"
				"return " method ".apply(" localVarName ", arguments);\n"
			"} else if (" method " !== undefined) {\n"
				"if (" localValueName " === undefined) {\n"
					"return " method ';\n'
				"}\n"
				method " = " localValueName ";\n"
			"}"
			"return " localVarName ';\n'
		'})'] | join | ctx
}


generateWhile := (expr env ctx)->{
	['while (' (expr.0 generate env ctx0) ') {\n'
			(expr.2 generate env ctx0)
		"}\n"
		('null' ctx)] join
}

generateBreak := (expr env ctx)->{
	'break'
}

generateEmpty := (expr env ctx)->{
	0 ctx
}

generateDef := (expr env ctx)->{
	varname := expr.[0].[0]
	ret := [
		'var ' varname ' = ' (expr.2 generate env ctx0) ";\n"
		(varname ctx)
	] | join
	env.[varname] = true
	ret
}

generateAssign := (expr env ctx)->{
	varname := expr.0 getVarName
	if (env.[varname] == undefined) {
		varname console.log
		"var undefined" console.log
	}

	["("
			(expr.0 generate env ctx0) " = " (expr.2 generate env ctx0)
	")"] | join | ctx
}

generateFunc := (expr env ctx)->{
	funcEnv := env env_new
	args := expr.0 generateFuncArgs funcEnv ctx0
	body := expr.2 generate funcEnv (v)->{
		'return ' + v
	}
	['(function (' args ') {\n' body '\n})'] | join | ctx
}

generateExpr := (expr env ctx)->{
	func := (expr.1 generate env ctx0)
	args := (expr.0 generate env ctx0)
	expr foreach (item index)->{
		if (index > 1) {
			args = [args ', ' (item generate env ctx0)] join
		}
	}
	[func '(' args ')'] | join | ctx
}

generateStart := (expr env ctx)->{
	expr.0 generate env ctx
}

generateMono := (expr env ctx)->{
	expr.0 generate env ctx
}

generate := (expr env ctx)->{
	if (expr.1 == '{start}') {
		expr generateStart env ctx
	} (expr.1 == '{seq}') {
		expr generateSeq env ctx
	} (expr.1 == '{mono}') {
		expr generateMono env ctx
	} (expr.1 == '{atomic}') {
		expr generateAtomic env ctx
	} (expr.1 == '{.}') {
		expr generateFieldAccess env ctx
	} (expr.1 == '{func}') {
		expr generateFunc env ctx
	} (expr.1 == '{array}') {
		expr generateArray env ctx
	} (expr.1 == '{object}') {
		expr generateObjectLiteral env ctx
	} (expr.1 == '{method}') {
		expr generateMethod env ctx
	} (expr.1 == '{empty}') {
		expr generateEmpty env ctx
	} (expr.1 == ':=') {
		expr generateDef env ctx
	} (expr.1 == '=') {
		expr generateAssign env ctx
	} (expr.1 == 'if') {
		expr generateIf env ctx
	} (expr.1 == 'and') {
		expr generateAnd env ctx
	} (expr.1 == 'or') {
		expr generateOr env ctx
	} (expr.1 == 'while') {
		expr generateWhile env ctx
	} (expr.1 == 'break') {
		expr generateBreak env ctx
	} else {
		expr generateExpr env ctx
	}
}

env_new := (env)->{
	env = env or {
		.print true
		.not true
		._instance_ true
		.__gt__ true
		.__ge__ true
		.__eq__ true
		.__le__ true
		.__lt__ true
		.__add__ true
		.__sub__ true
		.__mul__ true
		.__div__ true
		.__mod__ true
		.isFunction true
		.isArray true
		.foreach true
		.call true
		.apply true
		.exports true
	}

	Env := ()->{}
	Env.prototype = env
	Env _instance_
}

exports.compile = (expr)->{
	libs := [
		"function print(x) {\n return console.log(x); \n}"
		"function not(x) {\n return !x;\n}"
		"function _instance_(x) {\n return new x(); \n}"
		"function __add__(x, y) {\n return x + y;\n}"
		"function __sub__(x, y) {\n return x - y;\n}"
		"function __mul__(x, y) {\n return x * y;\n}"
		"function __div__(x, y) {\n return x / y;\n}"
		"function __mod__(x, y) {\n return x % y;\n}"
		"function __gt__(x, y) {\n return x > y;\n}"
		"function __ge__(x, y) {\n return x >= y;\n}"
		"function __eq__(x, y) {\n return x == y;\n}"
		"function __le__(x, y) {\n return x <= y;\n}"
		"function __lt__(x, y) {\n return x < y;\n}"
		"function isFunction(x) {\n return typeof x === 'function';\n}"
		"function isArray(x) {\n return x instanceof Array;\n}"
		"function foreach(arr, cb) {\n for (var i in arr) { cb(arr[i], i); };\n}"
		"function call(fn) {\n var collect = []; for (var i in arguments) { collect.push(arguments[i]); }; collect.shift(); return fn.apply(fn, collect); \n}"
		"function apply(fn) {\n return fn.apply(fn, arguments[1]); \n}"
	] .join "\n"

	[libs "\n" (expr generate (env_new call) ctx0)] join | console.log
}
